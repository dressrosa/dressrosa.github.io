---
title: 浅谈点赞评论后对于推送的逻辑处理
date: 2017-07-27 09:29:09
categories: "idea"
tags:
    - mq -
---
不管是app还是h5,现在大多数都是以内容为上,而内容为核心的交互往往就是点赞评论或许还可以打赏等.而这些操作以后,就涉及到消息的推送处理.  
这里的逻辑看起来非常简单,就是点赞或者评论后,发一条消息给对方表面谁给你点赞或者评论了.但是其中需要考虑的东西还是不少的.  
1.首先我们考虑下哪些情况需要推送,并不是所有的点赞和评论都需要推送. 
<!--more--> 
这里以评论为例.一般有哪些评论:
- 评论自己(或别人)的文章
- 回复自己(或别人)的评论
- 评论文章并@了自己(或别人)
- 回复自己(或别人)并@了自己(或别人)  

这里面就有区分自己和别人,可能还有多人的情况以及@人后推送几条的问题,还有自己@自己这种看起来不可能的事情.不管如何,程序就必须各种情况都要考虑到.比如这里自己给自己文章评论就没必要推送给自己,比如评论别人并@了人,那么就需要给作者推送一条和@对象推送一条(多条).

2.怎样去屏蔽一些没必要的推送  
这里常见的比如对一篇文章进行不停的点赞取消点赞取消操作,这时候如果每一条都要推送,这简直就会烦死人了.这种情况,一我们可以在前端做一下判断,比如连续很快的点击操作会被禁止,这样就可以避免一些恶意操作.二.我们在对同一用户的同一操作的多次行为不予响应,也就是我们只在第一次点赞进行推送,后面取消再点赞就不再进行推送了.对于点赞人来讲,推送的动作对于他并无影响,而对于作者来讲,他只关心这个人是否点了赞.这样处理是完全可行的.  

3.技术层面的处理  
代码逻辑上推荐采用消息队列的方式.对于消息队列的封装可以参见我的github([celery](https://github.com/dressrosa/celery)).
采用消息队列的好处在于异步处理而且不影响主线业务的进行.我这里建议两点.  
一是put消息时,最好只是需要传核心参数,而不要在主线业务逻辑里面进行消息的参数处理.意思是我们put给消息的参数最好不要再有二次查询,所有的逻辑应该放在消费者那里进行.这样才能提现异步的好处.  
二.消费者那里不要抛出异常.我在做业务的时候需要调用另一个同事的接口,结果有一天他那里出错了.而导致我这边业务无法进行.这里我是在业务里全改为try{}catch()了.但是真正的调用方是不关心也不应该出现异常的.所以在消费者端应该对异常有个统一的处理,即使是错误也是返回统一错误码而不是异常.  

好了,暂时就总结这么多,仅供参考.对于消息的后续处理以后有机会再总结.